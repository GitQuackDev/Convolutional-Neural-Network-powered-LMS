# Story 1.8: Collaborative Content Annotations

## Status
Draft

## Story
**As a** student and instructor,
**I want** to add real-time collaborative annotations to uploaded content,
**so that** enhanced interaction is possible while preserving existing content viewing and analysis features.

## Acceptance Criteria
1. Annotation system allows real-time commenting on CNN analysis results and uploaded content
2. Annotations integrate with existing content display without disrupting current viewing experience
3. Collaborative features respect current course permissions and user roles
4. Annotation data is stored efficiently and doesn't impact content loading performance
5. Users can control annotation visibility and participation preferences

## Tasks / Subtasks

- [ ] Create collaborative annotation database schema (AC: 4)
  - [ ] Design `collaboration_annotations` collection schema for Story 1.1 completion
  - [ ] Add annotation positioning data for precise content targeting
  - [ ] Implement annotation threading support for discussion chains
  - [ ] Add annotation visibility and permission controls

- [ ] Build annotation overlay system for content display (AC: 1, 2)
  - [ ] Create `AnnotationOverlay.tsx` component for content annotation display
  - [ ] Implement precise positioning system for annotations on analysis results
  - [ ] Add annotation markers and highlights for CNN analysis components
  - [ ] Design non-intrusive annotation indicators that preserve existing UI

- [ ] Implement real-time annotation collaboration (AC: 1, 3)
  - [ ] Connect to `/collaboration` namespace from Story 1.3 WebSocket infrastructure
  - [ ] Add real-time annotation creation, editing, and deletion
  - [ ] Implement live annotation updates for all course participants
  - [ ] Add collaborative annotation threading and discussion features

- [ ] Add annotation management and controls (AC: 3, 5)
  - [ ] Implement course permission-based annotation access
  - [ ] Add instructor moderation controls for annotation content
  - [ ] Create annotation visibility toggles (public, instructor-only, private)
  - [ ] Add annotation filtering by user, date, and content type

- [ ] Integrate annotations with existing content views (AC: 2)
  - [ ] Embed annotation system into `ContentUploadInterface.tsx` results display
  - [ ] Add annotation support to CNN analysis result components
  - [ ] Implement annotation display in course content views
  - [ ] Ensure backward compatibility with existing content viewing workflows

## Dev Notes

### Relevant Source Tree Information

**Existing Content Display Components:**
- `frontend/src/components/upload/ContentUploadInterface.tsx` - Main content upload and analysis results display
- `frontend/src/components/courses/CourseModuleView.tsx` - Course content viewing interface
- `frontend/src/types/upload.ts` - Content analysis and display type definitions

**WebSocket Infrastructure from Story 1.3:**
- `/collaboration` namespace for collaborative features and annotations
- Real-time event broadcasting patterns for collaborative interactions
- WebSocket authentication using existing JWT system

**Authentication and Permissions:**
- `frontend/src/contexts/AuthContext.tsx` - User authentication and role management
- Existing course enrollment and permission verification patterns
- Role-based access control (student, professor, admin)

**Technology Stack Context:**
- React 19.1.1 with TypeScript for component development
- MongoDB with Prisma ORM for annotation data persistence
- shadcn/ui component library for consistent annotation UI
- Framer Motion for annotation animations and interactions
- WebSocket integration for real-time collaborative features

**Key Implementation Points:**
1. Annotations must overlay existing content without disrupting current viewing experience
2. Use existing course permission patterns for annotation access control
3. Integrate with established WebSocket infrastructure for real-time collaboration
4. Follow existing shadcn/ui design patterns for annotation UI components
5. Maintain backward compatibility with existing content display workflows

**Files to Create:**
- `frontend/src/components/collaboration/` - New collaboration component directory
  - `AnnotationOverlay.tsx` - Main annotation overlay system
  - `AnnotationMarker.tsx` - Individual annotation marker component
  - `AnnotationThread.tsx` - Annotation discussion thread component
  - `AnnotationControls.tsx` - Annotation visibility and management controls
  - `AnnotationTooltip.tsx` - Annotation preview and interaction tooltip
  - `index.ts` - Collaboration component exports
- `frontend/src/hooks/useAnnotations.ts` - Annotation state management and WebSocket integration
- `backend/src/routes/annotations.ts` - Annotation API endpoints
- `backend/src/controllers/annotationController.ts` - Annotation CRUD operations

**Files to Modify:**
- `frontend/src/components/upload/ContentUploadInterface.tsx` - Integrate annotation overlay
- `frontend/src/components/courses/CourseModuleView.tsx` - Add annotation support
- `frontend/src/types/upload.ts` - Add annotation type definitions
- `backend/prisma/schema.prisma` - Add collaboration_annotations model

### Database Schema Design

**Collaboration Annotations Collection:**
```typescript
// collaboration_annotations collection schema for Story 1.1 completion
model CollaborationAnnotation {
  id                String   @id @default(auto()) @map("_id") @db.ObjectId
  contentId         String   @db.ObjectId // Reference to analyzed content
  contentType       ContentType  // CNN_ANALYSIS, UPLOAD_FILE, COURSE_MODULE
  authorId          String   @db.ObjectId
  courseId          String   @db.ObjectId
  
  // Annotation positioning and targeting
  position          Json     // { x, y, width, height } for overlay positioning
  targetElement     String?  // CSS selector or element ID for precise targeting
  anchorText        String?  // Text snippet for text-based annotations
  
  // Annotation content
  content           String
  annotationType    AnnotationType @default(COMMENT)
  isResolved        Boolean  @default(false)
  resolvedAt        DateTime?
  resolvedBy        String?  @db.ObjectId
  
  // Threading support
  parentId          String?  @db.ObjectId // For threaded discussions
  threadDepth       Int      @default(0)
  
  // Visibility and permissions
  visibility        AnnotationVisibility @default(PUBLIC)
  allowReplies      Boolean  @default(true)
  isHighlighted     Boolean  @default(false)
  
  // Metadata
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  editedAt          DateTime?
  isEdited          Boolean  @default(false)
  
  // Relations
  author            User     @relation("AnnotationAuthor", fields: [authorId], references: [id])
  course            Course   @relation(fields: [courseId], references: [id])
  parent            CollaborationAnnotation? @relation("AnnotationThread", fields: [parentId], references: [id])
  replies           CollaborationAnnotation[] @relation("AnnotationThread")
  resolver          User?    @relation("AnnotationResolver", fields: [resolvedBy], references: [id])
  
  @@map("collaboration_annotations")
  @@index([courseId, contentId, createdAt])
  @@index([authorId, createdAt])
  @@index([parentId, threadDepth])
}

enum ContentType {
  CNN_ANALYSIS
  UPLOAD_FILE
  COURSE_MODULE
  ASSIGNMENT
}

enum AnnotationType {
  COMMENT
  QUESTION
  SUGGESTION
  HIGHLIGHT
  ISSUE
}

enum AnnotationVisibility {
  PUBLIC          // Visible to all course participants
  INSTRUCTORS     // Visible to instructors only
  PRIVATE         // Visible to author only
  RESOLVED        // Archived/resolved annotations
}
```

### Component Architecture

**Annotation Overlay System:**
```typescript
// Main annotation overlay component
interface AnnotationOverlayProps {
  contentId: string;
  contentType: ContentType;
  courseId: string;
  readonly?: boolean;
  showResolved?: boolean;
  allowNewAnnotations?: boolean;
}

// Annotation marker component
interface AnnotationMarkerProps {
  annotation: CollaborationAnnotation;
  position: AnnotationPosition;
  isActive?: boolean;
  onClick?: (annotation: CollaborationAnnotation) => void;
  onEdit?: (annotationId: string, content: string) => void;
  onResolve?: (annotationId: string) => void;
}

// Annotation thread component
interface AnnotationThreadProps {
  rootAnnotation: CollaborationAnnotation;
  replies: CollaborationAnnotation[];
  onReply?: (parentId: string, content: string) => void;
  onEdit?: (annotationId: string, content: string) => void;
  maxDepth?: number;
}

// Annotation controls component
interface AnnotationControlsProps {
  currentUser: User;
  courseId: string;
  permissions: AnnotationPermissions;
  onVisibilityChange?: (visibility: AnnotationVisibility) => void;
  onCreateAnnotation?: (position: AnnotationPosition, content: string) => void;
}
```

**Annotation Positioning System:**
```typescript
// Precise annotation positioning
interface AnnotationPosition {
  x: number;              // X coordinate relative to content container
  y: number;              // Y coordinate relative to content container
  width?: number;         // Annotation width for highlights
  height?: number;        // Annotation height for highlights
  targetSelector?: string; // CSS selector for precise element targeting
  anchorText?: string;    // Text selection anchor for text annotations
}

// Annotation interaction events
interface AnnotationInteraction {
  type: 'create' | 'edit' | 'delete' | 'resolve' | 'reply';
  annotationId?: string;
  position?: AnnotationPosition;
  content?: string;
  visibility?: AnnotationVisibility;
}
```

**WebSocket Integration:**
```typescript
// Real-time annotation events using /collaboration namespace
interface AnnotationWebSocketEvents {
  'annotation_created': (annotation: CollaborationAnnotation) => void;
  'annotation_updated': (annotationId: string, changes: Partial<CollaborationAnnotation>) => void;
  'annotation_deleted': (annotationId: string) => void;
  'annotation_resolved': (annotationId: string, resolvedBy: string) => void;
  'annotation_highlighted': (annotationId: string, isHighlighted: boolean) => void;
  'user_annotating': (userId: string, position: AnnotationPosition) => void;
}

// Annotation state management hook
interface UseAnnotationsReturn {
  annotations: CollaborationAnnotation[];
  isLoading: boolean;
  isConnected: boolean;
  createAnnotation: (position: AnnotationPosition, content: string, type: AnnotationType) => void;
  editAnnotation: (annotationId: string, content: string) => void;
  deleteAnnotation: (annotationId: string) => void;
  resolveAnnotation: (annotationId: string) => void;
  replyToAnnotation: (parentId: string, content: string) => void;
  setAnnotationVisibility: (annotationId: string, visibility: AnnotationVisibility) => void;
}
```

### Backend API Design

**Annotation API Endpoints:**
```typescript
// RESTful annotation endpoints
GET /api/annotations/:contentId                   // Get annotations for content
POST /api/annotations                            // Create new annotation
PUT /api/annotations/:annotationId               // Edit annotation
DELETE /api/annotations/:annotationId            // Delete annotation
POST /api/annotations/:annotationId/resolve      // Resolve annotation
POST /api/annotations/:annotationId/reply        // Reply to annotation
PUT /api/annotations/:annotationId/visibility    // Change annotation visibility

// Course-level annotation endpoints
GET /api/courses/:courseId/annotations           // Get all course annotations
GET /api/courses/:courseId/annotations/unresolved // Get unresolved annotations
POST /api/courses/:courseId/annotations/bulk     // Bulk annotation operations
```

**Annotation Controller Methods:**
```typescript
// Annotation controller implementation
class AnnotationController {
  async getContentAnnotations(req: Request, res: Response): Promise<void>;
  async createAnnotation(req: Request, res: Response): Promise<void>;
  async editAnnotation(req: Request, res: Response): Promise<void>;
  async deleteAnnotation(req: Request, res: Response): Promise<void>;
  async resolveAnnotation(req: Request, res: Response): Promise<void>;
  async replyToAnnotation(req: Request, res: Response): Promise<void>;
  async changeAnnotationVisibility(req: Request, res: Response): Promise<void>;
  async getCourseAnnotations(req: Request, res: Response): Promise<void>;
  async getUnresolvedAnnotations(req: Request, res: Response): Promise<void>;
}
```

### Integration with Existing Content Views

**Content Upload Interface Integration:**
```typescript
// Enhanced ContentUploadInterface with annotations
interface EnhancedContentUploadProps extends ContentUploadProps {
  annotationsEnabled?: boolean;
  allowAnnotationCreation?: boolean;
  showResolvedAnnotations?: boolean;
  annotationPermissions?: AnnotationPermissions;
}

// Annotation integration in analysis results
const AnnotatedAnalysisResults: React.FC<{
  result: CNNAnalysisResult;
  annotations: CollaborationAnnotation[];
  onCreateAnnotation: (position: AnnotationPosition, content: string) => void;
}> = ({ result, annotations, onCreateAnnotation }) => {
  return (
    <div className="relative">
      <AnalysisResults result={result} />
      <AnnotationOverlay 
        contentId={result.uploadId}
        contentType="CNN_ANALYSIS"
        annotations={annotations}
        onCreateAnnotation={onCreateAnnotation}
      />
    </div>
  );
};
```

**Course Module View Integration:**
```typescript
// Enhanced CourseModuleView with annotation support
interface AnnotatedCourseModuleProps extends CourseModuleViewProps {
  annotationsEnabled?: boolean;
  courseId: string;
  userPermissions: AnnotationPermissions;
}

// Annotation overlay for course content
const AnnotatedCourseContent: React.FC<{
  content: CourseContent;
  courseId: string;
  annotations: CollaborationAnnotation[];
}> = ({ content, courseId, annotations }) => {
  return (
    <div className="relative">
      <CourseContent content={content} />
      <AnnotationOverlay
        contentId={content.id}
        contentType="COURSE_MODULE"
        courseId={courseId}
        annotations={annotations}
        readonly={!content.allowAnnotations}
      />
    </div>
  );
};
```

### Permission and Access Control

**Annotation Permissions System:**
```typescript
// Role-based annotation permissions
interface AnnotationPermissions {
  canCreate: boolean;
  canEdit: boolean;
  canDelete: boolean;
  canResolve: boolean;
  canModerate: boolean;
  canViewPrivate: boolean;
  canChangeVisibility: boolean;
  maxAnnotationsPerContent?: number;
}

// Permission verification service
class AnnotationPermissionService {
  async getUserAnnotationPermissions(userId: string, courseId: string): Promise<AnnotationPermissions>;
  async canUserAnnotateContent(userId: string, contentId: string): Promise<boolean>;
  async canUserEditAnnotation(userId: string, annotationId: string): Promise<boolean>;
  async canUserViewAnnotation(userId: string, annotation: CollaborationAnnotation): Promise<boolean>;
  async canUserModerateAnnotations(userId: string, courseId: string): Promise<boolean>;
}
```

**Course Enrollment Integration:**
```typescript
// Integration with existing course enrollment system
interface CourseAnnotationAccess {
  isEnrolled: boolean;
  role: 'student' | 'professor' | 'admin';
  annotationQuota: number;
  annotationsUsed: number;
  canCreatePublicAnnotations: boolean;
  canModerateCourseAnnotations: boolean;
}
```

### Performance Optimizations

**Annotation Loading Strategy:**
- Lazy loading of annotations based on viewport visibility
- Pagination for annotation threads with many replies
- Caching of frequently accessed annotation data
- Efficient WebSocket event batching for real-time updates

**Rendering Optimizations:**
- Virtual scrolling for annotation lists with many items
- Debounced annotation position updates during content scrolling
- Memoized annotation marker rendering to prevent unnecessary re-renders
- Efficient DOM manipulation for annotation overlay positioning

**Database Query Optimization:**
- Indexed queries for content-based annotation retrieval
- Aggregated queries for annotation statistics and counts
- Efficient threading queries with depth limits
- Bulk annotation operations for course-level management

### Previous Story Context

**From Story 1.1 (Database Schema Enhancement):**
- Database infrastructure ready for `collaboration_annotations` collection
- Integration with existing User and Course models established
- Proper indexing strategy for efficient annotation queries

**From Story 1.3 (WebSocket Infrastructure Foundation):**
- `/collaboration` namespace configured for real-time annotation collaboration
- WebSocket authentication and permission verification established
- Real-time event broadcasting patterns for collaborative features

**From Story 1.4 (Basic Analytics Data Collection):**
- Analytics middleware will track annotation usage patterns and engagement
- User interaction data includes annotation creation and collaboration metrics

**From Story 1.6 (Real-time Analytics Dashboard):**
- Annotation collaboration metrics integrated into analytics dashboard
- Real-time annotation activity monitoring and participation tracking

**From Story 1.7 (In-Context Communication Features):**
- Chat integration provides context for annotation discussions
- Shared WebSocket infrastructure for communication and collaboration
- Consistent UI patterns for real-time collaborative features

### User Experience Design

**Annotation Interaction Patterns:**
- **Click-to-Annotate**: Single click on content to create new annotations
- **Hover Preview**: Annotation markers show preview on hover
- **Thread Expansion**: Annotation threads expand inline or in sidebar
- **Drag Positioning**: Annotations can be repositioned for better visibility

**Visual Design Integration:**
- Annotation markers use existing shadcn/ui Badge and Tooltip components
- Annotation threads follow existing Card and Comment design patterns
- Color coding for different annotation types and user roles
- Subtle animations using Framer Motion for annotation interactions

**Responsive Annotation Display:**
- **Desktop**: Sidebar annotation panel with inline markers
- **Tablet**: Bottom panel annotation view with condensed markers
- **Mobile**: Full-screen annotation overlay with touch-optimized controls

### Testing

**Test File Locations:**
- `frontend/src/components/collaboration/__tests__/AnnotationOverlay.test.tsx` - Annotation overlay tests
- `frontend/src/components/collaboration/__tests__/AnnotationMarker.test.tsx` - Annotation marker tests
- `frontend/src/hooks/__tests__/useAnnotations.test.ts` - Annotation state management tests
- `backend/src/controllers/__tests__/annotationController.test.ts` - Annotation API tests

**Testing Frameworks:**
- Vitest + Testing Library for React component testing
- Jest for backend unit testing
- Socket.io-client for real-time collaboration testing
- Supertest for annotation API endpoint testing

**Testing Requirements:**
1. **Unit Tests:**
   - Annotation component rendering and interaction
   - Annotation positioning and overlay system
   - Permission verification and access control
   - WebSocket annotation event handling

2. **Integration Tests:**
   - End-to-end annotation workflow from creation to collaboration
   - Real-time annotation updates across multiple users
   - Annotation integration with existing content views
   - Course permission and enrollment verification

3. **Performance Tests:**
   - Annotation rendering performance with large numbers of annotations
   - Real-time collaboration performance under high concurrent usage
   - Content loading performance with annotation overlays
   - WebSocket connection stability during extended annotation sessions

4. **User Experience Tests:**
   - Annotation positioning accuracy and precision
   - Responsive design across different devices and screen sizes
   - Accessibility features for annotation interaction
   - Integration with existing content viewing workflows

**Testing Standards:**
- Minimum 80% code coverage for annotation components and functionality
- Performance benchmarks for annotation rendering and real-time updates
- Mock WebSocket connections and database interactions for consistent testing
- Test both standalone and integrated annotation modes

### Technical Constraints

**Integration Requirements:**
- Annotations must overlay existing content without disrupting current viewing experience
- Use established course permission and enrollment verification patterns
- Leverage existing WebSocket infrastructure for real-time collaboration
- Maintain current responsive design and accessibility standards

**Performance Requirements:**
- Annotation system must not impact existing content loading performance
- Real-time annotation updates should not cause UI lag or blocking
- Annotation overlay must remain responsive with large numbers of annotations
- WebSocket connections must handle graceful disconnection and reconnection

**Data Storage Requirements:**
- Efficient annotation storage with proper indexing for performance
- Annotation data must integrate with existing course and user data
- Support for annotation archiving and data retention policies
- Scalable annotation threading with reasonable depth limits

## Testing

### Testing Standards
**Source: PRD Testing Integration Strategy**

**Test Framework:** Vitest + Testing Library for frontend, Jest for backend, Socket.io-client for real-time testing
**Test File Location:** Component-specific test directories following existing patterns
**Testing Patterns:** Maintain current testing patterns while adding collaboration-specific annotation tests

**Required Testing Approaches:**
1. **Unit Tests:** Annotation components, positioning system, and permission verification
2. **Integration Tests:** Annotation integration with content views and real-time collaboration
3. **Performance Tests:** Annotation rendering, real-time updates, and concurrent collaboration
4. **End-to-End Tests:** Complete annotation workflow from creation to collaborative interaction

**Annotation-Specific Testing Requirements:**
- Test real-time annotation collaboration across multiple users
- Mock course permissions and annotation access control
- Test annotation positioning accuracy and overlay integration
- Validate annotation threading and discussion functionality

**Performance Testing Specific Requirements:**
- Load test annotation system with high annotation density
- Measure annotation rendering performance and real-time update latency
- Test annotation overlay performance with complex content layouts
- Validate annotation system impact on existing content view performance

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-31 | 1.0 | Initial story creation for collaborative content annotations | Scrum Master |
